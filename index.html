<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Cyber Tunnel 3D - Ultra Edition</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #000; 
            font-family: 'Orbitron', sans-serif;
            user-select: none;
            touch-action: none;
        }

        #ui-layer { 
            position: absolute; 
            top: 0; left: 0; width: 100%; height: 100%; 
            pointer-events: none; z-index: 10; color: #fff; 
        }

        .hud { padding: env(safe-area-inset-top) 20px 20px 20px; display: flex; justify-content: space-between; pointer-events: auto; }

        .glass-panel {
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 8px;
            padding: 12px 20px;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        .score-num {
            transition: transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275), color 0.2s;
            display: inline-block;
        }
        .score-bump {
            transform: scale(1.4);
            color: #00ffff !important;
        }
        .score-bump-cpu {
            transform: scale(1.4);
            color: #ff00ff !important;
        }

        .btn-neon {
            background: transparent;
            color: #00ffff;
            padding: 15px 40px;
            border: 2px solid #00ffff;
            cursor: pointer;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 4px;
            pointer-events: auto;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
            transition: all 0.3s ease;
        }
        .btn-neon:hover {
            background: #00ffff;
            color: #000;
            box-shadow: 0 0 40px #00ffff;
        }

        .color-dot {
            width: 38px;
            height: 38px;
            border-radius: 50%;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.2s;
            pointer-events: auto;
        }
        .color-dot.active { border-color: white; box-shadow: 0 0 15px currentColor; transform: scale(1.15); }

        .menu-overlay {
            position: absolute; inset: 0;
            background: radial-gradient(circle at center, rgba(0,20,40,0.9) 0%, rgba(0,0,0,1) 100%);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 50; pointer-events: auto;
        }

        .hidden { display: none !important; }

        #goal-overlay {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0);
            font-size: 8rem; font-weight: 900; font-style: italic;
            color: #fff; text-shadow: 0 0 20px #00ffff, 0 0 40px #00ffff;
            z-index: 100; pointer-events: none; opacity: 0;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        #goal-overlay.active {
            transform: translate(-50%, -50%) scale(1.2);
            opacity: 1;
        }

        #click-prompt {
            position: absolute; bottom: 20%; left: 50%; transform: translateX(-50%);
            color: #00ffff; font-weight: 900; letter-spacing: 8px; text-transform: uppercase;
            animation: blink 0.8s infinite; pointer-events: none;
            text-shadow: 0 0 15px #00ffff;
        }

        #match-msg {
            position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%);
            font-size: 3.5rem; font-weight: 900; text-align: center;
            text-transform: uppercase; letter-spacing: 12px;
            z-index: 60; pointer-events: none; opacity: 0; transition: opacity 0.5s;
        }

        @keyframes blink { 0%, 100% { opacity: 0.2; } 50% { opacity: 1; } }
    </style>
</head>
<body>

<div id="game-overlay" style="position: absolute; inset: 0; z-index: 1;"></div>

<div id="ui-layer">
    <div class="hud">
        <div class="glass-panel border-l-4 border-l-cyan-500 min-w-[160px]">
            <div id="level-val" class="text-xs tracking-[0.2em] text-cyan-400 font-bold uppercase">LIVELLO 01</div>
            <div id="score-total" class="text-2xl font-black text-white mt-1 leading-none tracking-tighter">0000</div>
        </div>
        
        <div class="flex items-center gap-10 glass-panel px-6 md:px-16">
            <div class="text-center">
                <div class="text-[10px] opacity-60 uppercase mb-1 tracking-widest">Utente</div>
                <div id="player-score" class="score-num text-3xl md:text-6xl font-black text-white leading-none">0</div>
            </div>
            <div class="h-12 w-[1px] bg-white/20"></div>
            <div class="text-center">
                <div class="text-[10px] opacity-60 uppercase mb-1 tracking-widest">Cortex</div>
                <div id="cpu-score" class="score-num text-3xl md:text-6xl font-black text-pink-500 leading-none">0</div>
            </div>
        </div>

        <div class="glass-panel text-right border-r-4 border-r-pink-500 min-w-[110px]">
            <div id="motion-indicator" class="text-[10px] opacity-60 uppercase mb-1">Link Speed</div>
            <div id="speed-indicator" class="text-2xl font-black text-pink-400 italic leading-none">0.0</div>
        </div>
    </div>

    <div id="goal-overlay">GOAL!</div>
    <div id="match-msg">LIVELLO COMPLETATO</div>

    <div id="start-screen" class="menu-overlay">
        <h1 class="text-5xl md:text-7xl font-black italic text-center mb-10 tracking-tighter">
            <span class="text-white">CYBER</span>
            <span class="text-cyan-400">TUNNEL</span>
        </h1>
        
        <div class="mb-14 text-center">
            <p class="text-xs uppercase tracking-[0.4em] text-cyan-500/60 mb-6">Seleziona Frequenza Colore</p>
            <div class="flex gap-4 justify-center flex-wrap max-w-md mx-auto px-4" id="color-selector">
                <div class="color-dot active" style="background: #00ffff; color: #00ffff;" onclick="selectColor(this, 0x00ffff)"></div>
                <div class="color-dot" style="background: #00ff00; color: #00ff00;" onclick="selectColor(this, 0x00ff00)"></div>
                <div class="color-dot" style="background: #ffff00; color: #ffff00;" onclick="selectColor(this, 0xffff00)"></div>
                <div class="color-dot" style="background: #ffaa00; color: #ffaa00;" onclick="selectColor(this, 0xffaa00)"></div>
                <div class="color-dot" style="background: #ff0077; color: #ff0077;" onclick="selectColor(this, 0xff0077)"></div>
                <div class="color-dot" style="background: #ff0000; color: #ff0000;" onclick="selectColor(this, 0xff0000)"></div>
                <div class="color-dot" style="background: #9d00ff; color: #9d00ff;" onclick="selectColor(this, 0x9d00ff)"></div>
                <div class="color-dot" style="background: #ffffff; color: #ffffff;" onclick="selectColor(this, 0xffffff)"></div>
            </div>
        </div>

        <button id="main-btn" class="btn-neon text-xl" onclick="initAndStart()">Inizia Sessione</button>
        <div class="mt-8 flex flex-col items-center gap-2">
            <p class="text-[10px] text-white/30 tracking-[0.3em] uppercase italic">Neural Link v4.2 Active</p>
            <p class="text-[9px] text-cyan-500/40 uppercase">Vincente a 6 punti | Accelerometro supportato</p>
        </div>
    </div>

    <div id="click-prompt" class="hidden text-sm">Clicca per Iniziare</div>
</div>

<script>
    // --- AUDIO ENGINE ---
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    let nextNoteTime = 0;
    const BPM = 128;
    const beatDuration = 60 / BPM;
    const sixteenth = beatDuration / 4; 
    let step = 0;
    let musicStartTime = 0;
    let isMusicActive = false;

    const bassPattern = [32.70, 0, 32.70, 32.70, 0, 0, 32.70, 0, 32.70, 0, 32.70, 32.70, 0, 32.70, 0, 0];
    const glitchPattern = [1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1];

    function resetMusicCounter() {
        step = 0;
        musicStartTime = audioCtx.currentTime;
        nextNoteTime = audioCtx.currentTime;
    }

    function playKick(time) {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.frequency.setValueAtTime(150, time);
        osc.frequency.exponentialRampToValueAtTime(0.01, time + 0.5);
        gain.gain.setValueAtTime(0.8, time);
        gain.gain.linearRampToValueAtTime(0, time + 0.5);
        osc.connect(gain); gain.connect(audioCtx.destination);
        osc.start(time); osc.stop(time + 0.5);
    }

    function playBass(time, freq) {
        if (freq === 0) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        const filter = audioCtx.createBiquadFilter();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(freq, time);
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(200, time);
        filter.frequency.exponentialRampToValueAtTime(1000, time + 0.1);
        gain.gain.setValueAtTime(0.3, time);
        gain.gain.linearRampToValueAtTime(0, time + sixteenth * 2);
        osc.connect(filter); filter.connect(gain); gain.connect(audioCtx.destination);
        osc.start(time); osc.stop(time + sixteenth * 2);
    }

    function playHat(time, open = false) {
        const noise = audioCtx.createBufferSource();
        const bufferSize = audioCtx.sampleRate * 0.1;
        const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
        noise.buffer = buffer;
        const filter = audioCtx.createBiquadFilter();
        filter.type = 'highpass';
        filter.frequency.value = 8000;
        const gain = audioCtx.createGain();
        gain.gain.setValueAtTime(open ? 0.15 : 0.1, time);
        gain.gain.exponentialRampToValueAtTime(0.01, time + (open ? 0.3 : 0.05));
        noise.connect(filter); filter.connect(gain); gain.connect(audioCtx.destination);
        noise.start(time); noise.stop(time + 0.5);
    }

    function playSnare(time) {
        const noise = audioCtx.createBufferSource();
        const bufferSize = audioCtx.sampleRate * 0.2;
        const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
        noise.buffer = buffer;
        const noiseFilter = audioCtx.createBiquadFilter();
        noiseFilter.type = 'highpass';
        noiseFilter.frequency.value = 1000;
        const noiseGain = audioCtx.createGain();
        noiseGain.gain.setValueAtTime(0.2, time);
        noiseGain.gain.exponentialRampToValueAtTime(0.01, time + 0.2);
        const osc = audioCtx.createOscillator();
        osc.frequency.setValueAtTime(180, time);
        const oscGain = audioCtx.createGain();
        oscGain.gain.setValueAtTime(0.3, time);
        oscGain.gain.exponentialRampToValueAtTime(0.01, time + 0.1);
        noise.connect(noiseFilter); noiseFilter.connect(noiseGain); noiseGain.connect(audioCtx.destination);
        osc.connect(oscGain); oscGain.connect(audioCtx.destination);
        noise.start(time); noise.stop(time + 0.2);
        osc.start(time); osc.stop(time + 0.2);
    }

    function playFixedGlitch(time, index) {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        gain.gain.setValueAtTime(0.06, time);
        gain.gain.exponentialRampToValueAtTime(0.005, time + 0.1);
        osc.type = 'sine';
        osc.frequency.setValueAtTime(800 + (index * 200), time);
        osc.connect(gain); gain.connect(audioCtx.destination);
        osc.start(time); osc.stop(time + 0.1);
    }

    function audioScheduler() {
        if (!isMusicActive) return;
        while (nextNoteTime < audioCtx.currentTime + 0.1) {
            const timeElapsed = audioCtx.currentTime - musicStartTime;
            const currentStep = step % 16;
            playBass(nextNoteTime, bassPattern[currentStep]);
            if (timeElapsed > 10 && currentStep % 4 === 0) playKick(nextNoteTime);
            if (timeElapsed > 20 && currentStep % 4 === 2) playHat(nextNoteTime, false);
            if (timeElapsed > 30) {
                if (currentStep === 4 || currentStep === 12) playSnare(nextNoteTime);
                if (currentStep === 14) playHat(nextNoteTime, true);
                if (glitchPattern[currentStep] === 1) playFixedGlitch(nextNoteTime, currentStep);
            }
            nextNoteTime += sixteenth;
            step++;
        }
    }

    function playGameSFX(freq, type, decay, vol = 0.1) {
        if (audioCtx.state === 'suspended') return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(freq * 0.1, audioCtx.currentTime + decay);
        gain.gain.setValueAtTime(vol, audioCtx.currentTime);
        gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + decay);
        osc.connect(gain); gain.connect(audioCtx.destination);
        osc.start(); osc.stop(audioCtx.currentTime + decay);
    }

    // --- THREE.JS ENGINE ---
    let scene, camera, renderer, ball, ballLight, playerPaddle, cpuPaddle, cpuLight, playerLight, arenaGroup;
    let spiralMesh, spiralCurve;
    let ballVelocity = new THREE.Vector3();
    let gameState = 'START'; 
    let stats = { level: 1, playerScore: 0, cpuScore: 0, totalPoints: 0, currentSpeed: 0 };
    let tunnelLines = [], sparkles = [], trail = [], lightRunners = [];
    let playerColor = 0x00ffff;
    
    const RADIUS = 13, BALL_RADIUS = 0.6, ARENA_DEPTH = 130; 
    const PADDLE_RADIUS = 5.2; 
    const WINNING_SCORE = 6;
    const MAX_BALL_SPEED = 1.8; 
    
    const PLAYER_EMISSIVE_BASE = 4;
    const CPU_EMISSIVE_BASE = 12;
    const HIT_INTENSITY_BOOST = 25;

    let pointerInput = { x: 0, y: 0 };
    let introProgress = 0;

    // --- MOTION CONTROL VARS ---
    let useMotion = false;
    let initialBeta = null, initialGamma = null;

    function selectColor(el, color) {
        document.querySelectorAll('.color-dot').forEach(d => d.classList.remove('active'));
        el.classList.add('active');
        playerColor = color;
        const hex = '#' + color.toString(16).padStart(6, '0');
        document.querySelector('.btn-neon').style.color = hex;
        document.querySelector('.btn-neon').style.borderColor = hex;
        document.getElementById('level-val').style.color = hex;
    }

    function createSparkle(pos, color) {
        for(let i=0; i<8; i++) {
            const geo = new THREE.BoxGeometry(0.15, 0.15, 0.15);
            const mat = new THREE.MeshBasicMaterial({ color: color });
            const spark = new THREE.Mesh(geo, mat);
            spark.position.copy(pos);
            spark.userData.vel = new THREE.Vector3((Math.random()-0.5)*0.8, (Math.random()-0.5)*0.8, (Math.random()-0.5)*0.8);
            spark.userData.life = 1.0;
            scene.add(spark);
            sparkles.push(spark);
        }
    }

    function initThree() {
        scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x000000, 20, 160); 
        camera = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(50, 25, 110);
        camera.lookAt(0, 0, 0);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        arenaGroup = new THREE.Group();
        scene.add(arenaGroup);

        const points = [];
        const loops = 40;
        const ptsPerLoop = 64;
        for (let i = 0; i <= loops * ptsPerLoop; i++) {
            const t = i / (loops * ptsPerLoop);
            const angle = t * loops * Math.PI * 2;
            const z = (t - 0.5) * ARENA_DEPTH;
            points.push(new THREE.Vector3(Math.cos(angle) * RADIUS, Math.sin(angle) * RADIUS, z));
        }
        spiralCurve = new THREE.CatmullRomCurve3(points);
        const spiralGeo = new THREE.TubeGeometry(spiralCurve, 1024, 0.05, 8, false); 
        const spiralMat = new THREE.MeshPhysicalMaterial({ 
            color: playerColor, 
            emissive: playerColor, 
            emissiveIntensity: 2.0,
            transparent: true,
            opacity: 0.8,
            roughness: 0,
            metalness: 1,
            clearcoat: 1.0
        });
        spiralMesh = new THREE.Mesh(spiralGeo, spiralMat);
        arenaGroup.add(spiralMesh);

        const runnerCount = 12;
        for(let i=0; i<runnerCount; i++) {
            const runnerGeo = new THREE.SphereGeometry(0.2, 8, 8);
            const runnerMat = new THREE.MeshBasicMaterial({ color: 0xe0f0ff }); 
            const runner = new THREE.Mesh(runnerGeo, runnerMat);
            const rLight = new THREE.PointLight(0xddeeff, 1.5, 5);
            runner.add(rLight);
            runner.userData = { offset: Math.random(), speed: 0.00002 + Math.random() * 0.00003 };
            arenaGroup.add(runner);
            lightRunners.push(runner);
        }

        const bgGeo = new THREE.CircleGeometry(RADIUS, 32);
        const bgMat = new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.05, side: THREE.DoubleSide });
        const backgroundWall = new THREE.Mesh(bgGeo, bgMat);
        backgroundWall.position.z = -ARENA_DEPTH/2 - 0.1;
        arenaGroup.add(backgroundWall);

        const lineCount = 16;
        for (let i = 0; i < lineCount; i++) {
            const angle = (i / lineCount) * Math.PI * 2;
            const x = Math.cos(angle) * RADIUS;
            const y = Math.sin(angle) * RADIUS;
            const lineGeo = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(x, y, -ARENA_DEPTH/2),
                new THREE.Vector3(x, y, ARENA_DEPTH/2)
            ]);
            const lineMat = new THREE.LineBasicMaterial({ color: playerColor, transparent: true, opacity: 0.1 });
            const line = new THREE.Line(lineGeo, lineMat);
            arenaGroup.add(line);
            tunnelLines.push(line);
        }

        ball = new THREE.Group();
        const ballMesh = new THREE.Mesh(
            new THREE.SphereGeometry(BALL_RADIUS, 32, 32),
            new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xffffff, emissiveIntensity: 3.5, depthTest: false })
        );
        ballMesh.renderOrder = 999; 
        ball.add(ballMesh);
        ballLight = new THREE.PointLight(0xffffff, 8, 30);
        ball.add(ballLight);
        scene.add(ball);

        for(let i=0; i<15; i++) {
            const p = new THREE.Mesh(
                new THREE.SphereGeometry(BALL_RADIUS * 0.8, 8, 8), 
                new THREE.MeshBasicMaterial({ color: playerColor, transparent: true, opacity: 0.5, depthTest: false })
            );
            p.renderOrder = 998;
            p.visible = false;
            scene.add(p);
            trail.push(p);
        }

        playerPaddle = createPaddle(playerColor, ARENA_DEPTH/2 - 8, PLAYER_EMISSIVE_BASE);
        playerLight = new THREE.PointLight(playerColor, 0, 40);
        playerPaddle.add(playerLight);

        cpuPaddle = createPaddle(0xff0088, -ARENA_DEPTH/2 + 8, CPU_EMISSIVE_BASE); 
        cpuLight = new THREE.PointLight(0xff0088, 25, 60); 
        cpuPaddle.add(cpuLight);
        
        scene.add(playerPaddle, cpuPaddle);
        scene.add(new THREE.AmbientLight(0xffffff, 0.15));
        setupInput();
    }

    function createPaddle(color, z, emissiveIntensity = 4) {
        const g = new THREE.Group();
        const main = new THREE.Mesh(new THREE.TorusGeometry(PADDLE_RADIUS, 0.1, 16, 64), new THREE.MeshStandardMaterial({ color, emissive: color, emissiveIntensity: emissiveIntensity }));
        for(let i=0; i<4; i++) {
            const flange = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.2, 1.2), new THREE.MeshStandardMaterial({ color, emissive: color, emissiveIntensity: emissiveIntensity }));
            flange.position.set(Math.cos(i*Math.PI/2)*PADDLE_RADIUS, Math.sin(i*Math.PI/2)*PADDLE_RADIUS, 0);
            flange.rotation.z = i*Math.PI/2;
            g.add(flange);
        }
        g.add(main);
        g.position.z = z;
        return g;
    }

    function setupInput() {
        const overlay = document.getElementById('game-overlay');
        const handleInput = (ex, ey) => {
            if (useMotion) return;
            pointerInput.x = (ex / window.innerWidth) * 2 - 1;
            pointerInput.y = -(ey / window.innerHeight) * 2 + 1;
        };
        overlay.addEventListener('mousemove', (e) => handleInput(e.clientX, e.clientY));
        overlay.addEventListener('touchstart', (e) => handleInput(e.touches[0].clientX, e.touches[0].clientY));
        overlay.addEventListener('touchmove', (e) => { handleInput(e.touches[0].clientX, e.touches[0].clientY); e.preventDefault(); }, { passive: false });
        overlay.addEventListener('click', () => { if (gameState === 'WAITING') launchBall(); });
    }

    function handleMotion(e) {
        if (!useMotion) return;
        if (initialBeta === null) {
            initialBeta = e.beta;
            initialGamma = e.gamma;
            return;
        }
        // Calcolo deviazione con sensibilitÃ  calibrata per il tunnel
        let dx = (e.gamma - initialGamma) * 0.08;
        let dy = (e.beta - initialBeta) * 0.08;
        pointerInput.x = Math.max(-1.3, Math.min(1.3, dx));
        pointerInput.y = Math.max(-1.3, Math.min(1.3, -dy));
    }

    let trailTimer = 0;
    let trailIdx = 0;

    function animate() {
        requestAnimationFrame(animate);
        audioScheduler(); 

        if (spiralMesh) spiralMesh.rotation.z += 0.003;

        lightRunners.forEach(r => {
            r.userData.offset += r.userData.speed;
            if (r.userData.offset > 1) r.userData.offset = 0;
            const pos = spiralCurve.getPointAt(r.userData.offset);
            r.position.copy(pos);
            const rot = spiralMesh.rotation.z;
            const x = r.position.x;
            const y = r.position.y;
            r.position.x = x * Math.cos(rot) - y * Math.sin(rot);
            r.position.y = x * Math.sin(rot) + y * Math.cos(rot);
        });

        if (playerPaddle) {
            const mat = playerPaddle.children[4].material; 
            mat.emissiveIntensity = THREE.MathUtils.lerp(mat.emissiveIntensity, PLAYER_EMISSIVE_BASE, 0.1);
            playerLight.intensity = THREE.MathUtils.lerp(playerLight.intensity, 0, 0.1);
        }
        if (cpuPaddle) {
            const mat = cpuPaddle.children[4].material;
            mat.emissiveIntensity = THREE.MathUtils.lerp(mat.emissiveIntensity, CPU_EMISSIVE_BASE, 0.1);
            cpuLight.intensity = THREE.MathUtils.lerp(cpuLight.intensity, 25, 0.05);
        }

        for(let i = sparkles.length-1; i>=0; i--) {
            const s = sparkles[i];
            s.position.add(s.userData.vel);
            s.userData.life -= 0.04;
            s.scale.setScalar(s.userData.life);
            if(s.userData.life <= 0) {
                scene.remove(s);
                sparkles.splice(i, 1);
            }
        }

        if (gameState === 'INTRO') {
            introProgress += 0.006;
            const startPos = new THREE.Vector3(60, 30, 120);
            const endPos = new THREE.Vector3(0, 2, ARENA_DEPTH/2 + 22);
            camera.position.lerpVectors(startPos, endPos, introProgress);
            camera.lookAt(0, 0, 0);
            if (introProgress >= 1) {
                gameState = 'WAITING';
                document.getElementById('click-prompt').classList.remove('hidden');
            }
        }

        if (gameState === 'WAITING' || gameState === 'PLAYING') {
            const limit = RADIUS - PADDLE_RADIUS - 0.5;
            playerPaddle.position.x = THREE.MathUtils.lerp(playerPaddle.position.x, pointerInput.x * limit * 1.8, 0.2); 
            playerPaddle.position.y = THREE.MathUtils.lerp(playerPaddle.position.y, pointerInput.y * limit * 1.8, 0.2);
            
            const targetCamX = playerPaddle.position.x * 0.4;
            const targetCamY = playerPaddle.position.y * 0.4 + 2;
            camera.position.x += (targetCamX - camera.position.x) * 0.1;
            camera.position.y += (targetCamY - camera.position.y) * 0.1;
            camera.position.z = ARENA_DEPTH/2 + 22;
            camera.lookAt(ball.position.x*0.15, ball.position.y*0.15, ball.position.z*0.5);
        }

        if (gameState === 'WAITING') {
            ball.position.set(playerPaddle.position.x, playerPaddle.position.y, playerPaddle.position.z - 3);
            trail.forEach(t => t.visible = false);
        }

        if (gameState === 'PLAYING') {
            ball.position.add(ballVelocity);
            ballVelocity.x *= 0.995; 
            ballVelocity.y *= 0.995;

            trailTimer++;
            if(trailTimer % 2 === 0) {
                const t = trail[trailIdx];
                t.position.copy(ball.position);
                t.visible = true;
                t.userData.life = 1.0;
                trailIdx = (trailIdx + 1) % trail.length;
            }
            trail.forEach(t => {
                if(t.visible) {
                    t.userData.life -= 0.05;
                    t.scale.setScalar(t.userData.life);
                    t.material.opacity = t.userData.life * 0.5;
                    if(t.userData.life <= 0) t.visible = false;
                }
            });

            if (Math.sqrt(ball.position.x**2 + ball.position.y**2) > RADIUS - BALL_RADIUS) {
                ballVelocity.reflect(new THREE.Vector3(ball.position.x, ball.position.y, 0).normalize());
                playGameSFX(120, 'sine', 0.1);
            }

            const aiDifficulty = 0.03 + (stats.level * 0.01); 
            cpuPaddle.position.x += (ball.position.x - cpuPaddle.position.x) * aiDifficulty;
            cpuPaddle.position.y += (ball.position.y - cpuPaddle.position.y) * aiDifficulty;
            
            const collDist = PADDLE_RADIUS + BALL_RADIUS;
            
            if (ballVelocity.z > 0 && ball.position.z > playerPaddle.position.z - 1.5) {
                if (Math.sqrt((ball.position.x - playerPaddle.position.x)**2 + (ball.position.y - playerPaddle.position.y)**2) < collDist) {
                    ballVelocity.z *= -1.04; 
                    ballVelocity.x += (ball.position.x - playerPaddle.position.x) * 0.35;
                    ballVelocity.y += (ball.position.y - playerPaddle.position.y) * 0.35;
                    if (Math.abs(ballVelocity.z) > MAX_BALL_SPEED) ballVelocity.z = Math.sign(ballVelocity.z) * MAX_BALL_SPEED;
                    playerPaddle.children[4].material.emissiveIntensity = HIT_INTENSITY_BOOST;
                    playerLight.intensity = 50;
                    playGameSFX(500, 'square', 0.15);
                    createSparkle(ball.position, 0xffffff);
                }
            }
            if (ballVelocity.z < 0 && ball.position.z < cpuPaddle.position.z + 1.5) {
                if (Math.sqrt((ball.position.x - cpuPaddle.position.x)**2 + (ball.position.y - cpuPaddle.position.y)**2) < collDist) {
                    ballVelocity.z *= -1.04;
                    if (Math.abs(ballVelocity.z) > MAX_BALL_SPEED) ballVelocity.z = Math.sign(ballVelocity.z) * MAX_BALL_SPEED;
                    cpuPaddle.children[4].material.emissiveIntensity = HIT_INTENSITY_BOOST * 1.5;
                    cpuLight.intensity = 80;
                    playGameSFX(400, 'square', 0.15);
                    createSparkle(ball.position, 0xff0088);
                }
            }

            if (ball.position.z > ARENA_DEPTH/2 + 5) handleGoal(false);
            if (ball.position.z < -ARENA_DEPTH/2 - 5) handleGoal(true);
            
            stats.currentSpeed = Math.abs(ballVelocity.z);
            updateUI();
        }

        renderer.render(scene, camera);
    }

    async function initAndStart() {
        if (audioCtx.state === 'suspended') await audioCtx.resume();
        
        // --- AUTO-MOTION REQUEST ---
        if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
            try {
                const permission = await DeviceOrientationEvent.requestPermission();
                if (permission === 'granted') {
                    useMotion = true;
                    window.addEventListener('deviceorientation', handleMotion);
                    document.getElementById('motion-indicator').innerText = "Neural Accel";
                }
            } catch(e) { console.warn("Motion permission denied"); }
        } else if ('ondeviceorientation' in window) {
            useMotion = true;
            window.addEventListener('deviceorientation', handleMotion);
            document.getElementById('motion-indicator').innerText = "Neural Accel";
        }

        resetMusicCounter();
        isMusicActive = true;
        
        const pColorObj = new THREE.Color(playerColor);
        playerPaddle.children.forEach(child => {
            if(child.material) {
                child.material.color.copy(pColorObj);
                child.material.emissive.copy(pColorObj);
            }
        });
        playerLight.color.copy(pColorObj);
        ballLight.color.copy(pColorObj);
        trail.forEach(t => t.material.color.copy(pColorObj));
        if (spiralMesh) {
            spiralMesh.material.color.copy(pColorObj);
            spiralMesh.material.emissive.copy(pColorObj);
        }
        tunnelLines.forEach(l => l.material.color.copy(pColorObj));

        document.getElementById('start-screen').classList.add('hidden');
        gameState = 'INTRO';
    }

    function launchBall() {
        document.getElementById('click-prompt').classList.add('hidden');
        gameState = 'PLAYING';
        const initialSpeed = 0.8 + (stats.level * 0.1);
        ballVelocity.set((Math.random()-0.5)*0.3, (Math.random()-0.5)*0.3, -initialSpeed);
    }

    function handleGoal(isP) {
        const goalEl = document.getElementById('goal-overlay');
        goalEl.innerText = "GOAL!";
        goalEl.style.textShadow = isP ? "0 0 20px #00ffff" : "0 0 20px #ff00ff";
        goalEl.classList.add('active');
        if (isP) { 
            stats.playerScore++; 
            bumpScore('player-score', 'score-bump');
            playGameSFX(800, 'sine', 0.5, 0.2);
        } else { 
            stats.cpuScore++; 
            bumpScore('cpu-score', 'score-bump-cpu');
            playGameSFX(200, 'sawtooth', 0.5, 0.2);
        }
        updateUI();
        gameState = 'GOAL_PAUSE';
        setTimeout(() => {
            goalEl.classList.remove('active');
            if (stats.playerScore >= WINNING_SCORE || stats.cpuScore >= WINNING_SCORE) {
                processMatchEnd();
            } else {
                gameState = 'WAITING';
                document.getElementById('click-prompt').classList.remove('hidden');
            }
        }, 1200);
    }

    function bumpScore(id, className) {
        const el = document.getElementById(id);
        el.classList.add(className);
        setTimeout(() => el.classList.remove(className), 300);
    }

    function processMatchEnd() {
        const won = stats.playerScore > stats.cpuScore;
        const delta = stats.playerScore - stats.cpuScore;
        const pointsChange = delta * 100;
        stats.totalPoints += pointsChange;
        const msg = document.getElementById('match-msg');
        if (stats.totalPoints < 0) {
            msg.innerText = "LINK INTERROTTO\nGAME OVER";
            msg.style.color = "#ff0000"; msg.style.opacity = 1;
            setTimeout(() => location.reload(), 4000);
            return;
        }
        if (won) {
            msg.innerText = `LIVELLO ${stats.level}\nSYNC COMPLETA`;
            stats.level += 1; 
        } else {
            msg.innerText = "SYNC FALLITA\nRIPETI LIVELLO";
        }
        msg.style.color = won ? "#00ffff" : "#ffaa00";
        msg.style.opacity = 1;
        setTimeout(() => {
            msg.style.opacity = 0;
            stats.playerScore = 0; 
            stats.cpuScore = 0;
            updateUI();
            resetMusicCounter(); 
            gameState = 'WAITING';
            document.getElementById('click-prompt').classList.remove('hidden');
        }, 3000);
    }

    function updateUI() {
        document.getElementById('player-score').innerText = stats.playerScore;
        document.getElementById('cpu-score').innerText = stats.cpuScore;
        document.getElementById('level-val').innerText = `LIVELLO ${stats.level.toString().padStart(2, '0')}`;
        document.getElementById('score-total').innerText = stats.totalPoints.toString().padStart(4, '0');
        document.getElementById('speed-indicator').innerText = stats.currentSpeed.toFixed(1);
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    window.onload = () => { initThree(); animate(); };
</script>
</body>
</html>
