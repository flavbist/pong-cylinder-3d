<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Cyber Tunnel 3D - Pro Evolution</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #000; 
            font-family: 'Orbitron', sans-serif;
            user-select: none;
            touch-action: none;
        }

        #ui-layer { 
            position: absolute; 
            top: 0; left: 0; width: 100%; height: 100%; 
            pointer-events: none; z-index: 10; color: #fff; 
        }

        .hud { padding: 20px; display: flex; justify-content: space-between; pointer-events: auto; }

        .glass-panel {
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 4px;
            padding: 12px 20px;
        }

        .btn-neon {
            background: transparent;
            color: #00ffff;
            padding: 15px 40px;
            border: 2px solid #00ffff;
            cursor: pointer;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 4px;
            pointer-events: auto;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
            transition: all 0.3s ease;
        }
        .btn-neon:hover {
            background: #00ffff;
            color: #000;
            box-shadow: 0 0 40px #00ffff;
        }

        .color-dot {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.2s;
            pointer-events: auto;
        }
        .color-dot:hover { transform: scale(1.2); }
        .color-dot.active { border-color: white; box-shadow: 0 0 15px currentColor; }

        .menu-overlay {
            position: absolute; inset: 0;
            background: rgba(0,0,0,0.95);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 50; pointer-events: auto;
        }

        .hidden { display: none !important; }

        #click-prompt {
            position: absolute; bottom: 25%; left: 50%; transform: translateX(-50%);
            color: #00ffff; font-weight: 900; letter-spacing: 8px; text-transform: uppercase;
            animation: blink 0.8s infinite; pointer-events: none;
            text-shadow: 0 0 10px #00ffff;
        }

        #match-msg {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 3rem; font-weight: 900; text-align: center;
            text-transform: uppercase; letter-spacing: 10px;
            z-index: 60; pointer-events: none; opacity: 0; transition: opacity 0.5s;
            text-shadow: 0 0 20px currentColor;
        }

        @keyframes blink { 0%, 100% { opacity: 0; } 50% { opacity: 1; } }
    </style>
</head>
<body>

<div id="game-overlay" style="position: absolute; inset: 0; z-index: 1;"></div>

<div id="ui-layer">
    <div class="hud">
        <div class="glass-panel border-l-4 border-l-cyan-500 min-w-[150px]">
            <div id="level-val" class="text-sm tracking-widest text-cyan-400">CORE LEVEL 01</div>
            <div id="score-total" class="text-xl font-black text-white mt-1">0000</div>
        </div>
        <div class="flex items-center gap-10 glass-panel px-12">
            <div class="text-center">
                <div class="text-[10px] opacity-50 uppercase mb-1">Tu</div>
                <div id="player-score" class="text-5xl font-black text-white leading-none">0</div>
            </div>
            <div class="h-10 w-[2px] bg-cyan-500/30"></div>
            <div class="text-center">
                <div class="text-[10px] opacity-50 uppercase mb-1">Cortex</div>
                <div id="cpu-score" class="text-5xl font-black text-pink-500 leading-none">0</div>
            </div>
        </div>
        <div class="glass-panel text-right border-r-4 border-r-pink-500 min-w-[100px]">
            <div class="text-[10px] opacity-50 uppercase mb-1">Velocità</div>
            <div id="speed-indicator" class="text-xl font-black text-pink-400 italic">0.0</div>
        </div>
    </div>

    <div id="match-msg">MATCH WIN!</div>

    <div id="start-screen" class="menu-overlay">
        <h1 class="text-6xl font-black italic text-center mb-8 tracking-tighter">
            <span class="text-white">CYBER</span>
            <span class="text-cyan-400">TUNNEL</span>
        </h1>
        
        <div class="mb-12 text-center">
            <p class="text-xs uppercase tracking-widest text-gray-400 mb-4">Scegli il tuo colore</p>
            <div class="flex gap-6 justify-center" id="color-selector">
                <div class="color-dot active" style="background: #00ffff; color: #00ffff;" onclick="selectColor(this, 0x00ffff)"></div>
                <div class="color-dot" style="background: #00ff00; color: #00ff00;" onclick="selectColor(this, 0x00ff00)"></div>
                <div class="color-dot" style="background: #ffff00; color: #ffff00;" onclick="selectColor(this, 0xffff00)"></div>
                <div class="color-dot" style="background: #ffaa00; color: #ffaa00;" onclick="selectColor(this, 0xffaa00)"></div>
                <div class="color-dot" style="background: #ffffff; color: #ffffff;" onclick="selectColor(this, 0xffffff)"></div>
            </div>
        </div>

        <button id="main-btn" class="btn-neon text-xl" onclick="initAndStart()">Avvia Sistema</button>
        <p class="text-[10px] text-cyan-500/50 mt-6 tracking-widest uppercase italic">Obiettivo: 6 Punti | 10 Livelli</p>
    </div>

    <div id="click-prompt" class="hidden text-sm">Pronto al Lancio</div>
</div>

<script>
    let scene, camera, renderer, ball, ballLight, playerPaddle, cpuPaddle, arenaGroup, starField;
    let ballVelocity = new THREE.Vector3();
    let gameState = 'START'; 
    let stats = { level: 1, playerScore: 0, cpuScore: 0, totalPoints: 0, currentSpeed: 0 };
    let smokeParticles = [];
    let trailParticles = [];
    let tunnelRings = [];
    
    // Configurazione
    let playerColor = 0x00ffff;
    const WINNING_SCORE = 6;
    const MAX_LEVELS = 10;
    
    // Controlli Ibridi
    let useMotion = false;
    let motionOffset = { beta: 0, gamma: 0 };
    let initialMotionSet = false;
    let currentInput = { x: 0, y: 0 };
    let motionInput = { x: 0, y: 0 };
    let pointerInput = { x: 0, y: 0 };

    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    let nextBeatTime = 0;
    const BPM = 126;
    const beatLen = 60 / BPM;

    // Parametri Arena
    const RADIUS = 10;
    const BALL_RADIUS = 0.8;
    const ARENA_DEPTH = 107.8; 
    const PADDLE_RADIUS = 4.2; 
    const PADDLE_THICKNESS = 0.08; 
    
    let targetSpeed = 1.4; 
    const SPEED_INCREMENT = 0.1; 
    const MAX_SPEED_CAP = 5.0; 

    let introProgress = 0;

    function selectColor(el, color) {
        document.querySelectorAll('.color-dot').forEach(d => d.classList.remove('active'));
        el.classList.add('active');
        playerColor = color;
        const hex = '#' + color.toString(16).padStart(6, '0');
        document.querySelector('.btn-neon').style.color = hex;
        document.querySelector('.btn-neon').style.borderColor = hex;
    }

    function playKick() {
        if (audioCtx.state !== 'running') return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        const time = audioCtx.currentTime;
        osc.frequency.setValueAtTime(150, time);
        osc.frequency.exponentialRampToValueAtTime(0.01, time + 0.4);
        gain.gain.setValueAtTime(0.4, time);
        gain.gain.linearRampToValueAtTime(0, time + 0.4);
        osc.connect(gain); gain.connect(audioCtx.destination);
        osc.start(); osc.stop(time + 0.4);
    }

    function scheduler() {
        while (nextBeatTime < audioCtx.currentTime + 0.1) {
            playKick();
            nextBeatTime += beatLen;
        }
    }

    function initThree() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x020205);
        scene.fog = new THREE.Fog(0x000000, 10, 300);
        
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.set(80, 40, 100);
        camera.lookAt(0, 0, 0);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        const ambLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambLight);

        arenaGroup = new THREE.Group();
        scene.add(arenaGroup);

        const tunnelGeo = new THREE.CylinderGeometry(RADIUS + 0.5, RADIUS + 0.5, ARENA_DEPTH, 48, 1, true);
        const tunnelMat = new THREE.MeshStandardMaterial({
            color: 0x0a0a0f,
            metalness: 0.1, 
            roughness: 0.8, 
            side: THREE.BackSide,
            emissive: 0x000811,
            emissiveIntensity: 0.1
        });
        const tunnel = new THREE.Mesh(tunnelGeo, tunnelMat);
        tunnel.rotation.x = Math.PI / 2;
        arenaGroup.add(tunnel);

        // ANELLI DEL TUNNEL
        const ringGeo = new THREE.TorusGeometry(RADIUS + 0.1, 0.05, 12, 64);
        const ringCount = 12;
        for (let i = 0; i < ringCount; i++) {
            const ringMat = new THREE.MeshStandardMaterial({ 
                color: playerColor, 
                emissive: playerColor, 
                emissiveIntensity: 1,
                transparent: true,
                opacity: 0.4
            });
            const ring = new THREE.Mesh(ringGeo, ringMat);
            ring.position.z = (i / (ringCount - 1) - 0.5) * ARENA_DEPTH;
            arenaGroup.add(ring);
            tunnelRings.push(ring);
        }

        const starGeo = new THREE.BufferGeometry();
        const starCoords = [];
        for(let i=0; i<1500; i++) starCoords.push((Math.random()-0.5)*1200, (Math.random()-0.5)*1200, (Math.random()-0.5)*2000);
        starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starCoords, 3));
        starField = new THREE.Points(starGeo, new THREE.PointsMaterial({ color: 0xffffff, size: 0.8, transparent: true, opacity: 0.5 }));
        scene.add(starField);

        ball = new THREE.Group();
        ball.add(new THREE.Mesh(new THREE.SphereGeometry(BALL_RADIUS, 32, 32), new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xffffff, emissiveIntensity: 2 })));
        ballLight = new THREE.PointLight(0x00ffff, 6, 40);
        ball.add(ballLight);
        scene.add(ball);

        playerPaddle = createPaddle(playerColor, ARENA_DEPTH/2 - 10);
        cpuPaddle = createPaddle(0xff00ff, -ARENA_DEPTH/2 + 10);
        scene.add(playerPaddle); scene.add(cpuPaddle);

        setupInput();
    }

    function createPaddle(color, z) {
        const g = new THREE.Group();
        const main = new THREE.Mesh(new THREE.TorusGeometry(PADDLE_RADIUS, PADDLE_THICKNESS, 16, 64), new THREE.MeshStandardMaterial({ color, emissive: color, emissiveIntensity: 2.5 }));
        const glow = new THREE.Mesh(new THREE.CircleGeometry(PADDLE_RADIUS, 32), new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.05, side: THREE.DoubleSide }));
        g.add(main); g.add(glow);
        g.position.z = z;
        return g;
    }

    function createSmokeEffect(pos, color = 0x888888, count = 8) {
        for(let i = 0; i < count; i++) {
            const size = Math.random() * 0.4 + 0.2;
            const p = new THREE.Mesh(new THREE.SphereGeometry(size, 8, 8), new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.6 }));
            p.position.copy(pos);
            p.userData = { velocity: new THREE.Vector3((Math.random()-0.5)*0.1, Math.random()*0.15+0.05, (Math.random()-0.5)*0.1), life: 1.0, decay: Math.random()*0.02+0.015 };
            scene.add(p);
            smokeParticles.push(p);
        }
    }

    function createTrailEffect() {
        const p = new THREE.Mesh(
            new THREE.SphereGeometry(BALL_RADIUS * 0.8, 8, 8),
            new THREE.MeshBasicMaterial({ 
                color: ballVelocity.z > 0 ? 0x00ffff : 0xff00ff, 
                transparent: true, 
                opacity: 0.4 
            })
        );
        p.position.copy(ball.position);
        p.userData = { life: 1.0, decay: 0.05 };
        scene.add(p);
        trailParticles.push(p);
    }

    function updateSmoke() {
        // Update smoke (collisions)
        for (let i = smokeParticles.length - 1; i >= 0; i--) {
            const p = smokeParticles[i];
            p.position.add(p.userData.velocity);
            p.scale.multiplyScalar(1.02);
            p.userData.life -= p.userData.decay;
            p.material.opacity = p.userData.life * 0.6;
            if (p.userData.life <= 0) { scene.remove(p); smokeParticles.splice(i, 1); }
        }

        // Update trail (movement)
        for (let i = trailParticles.length - 1; i >= 0; i--) {
            const p = trailParticles[i];
            p.userData.life -= p.userData.decay;
            p.scale.multiplyScalar(0.92);
            p.material.opacity = p.userData.life * 0.4;
            if (p.userData.life <= 0) { scene.remove(p); trailParticles.splice(i, 1); }
        }
    }

    function setupInput() {
        const overlay = document.getElementById('game-overlay');
        
        // Touch e Mouse per orientamento paddle
        const handleInput = (ex, ey) => {
            pointerInput.x = (ex / window.innerWidth) * 2 - 1;
            pointerInput.y = -(ey / window.innerHeight) * 2 + 1;
        };

        overlay.addEventListener('mousemove', (e) => handleInput(e.clientX, e.clientY));
        
        overlay.addEventListener('touchstart', (e) => {
            if (gameState === 'WAITING') launchBall();
            handleInput(e.touches[0].clientX, e.touches[0].clientY);
        }, { passive: false });

        overlay.addEventListener('touchmove', (e) => {
            handleInput(e.touches[0].clientX, e.touches[0].clientY);
            e.preventDefault(); // Impedisce scrolling
        }, { passive: false });

        overlay.addEventListener('click', () => { if (gameState === 'WAITING') launchBall(); });

        // Accelerometro/Giroscopio
        window.addEventListener('deviceorientation', (e) => {
            if (!useMotion) return;
            if (!initialMotionSet) {
                motionOffset.beta = e.beta; 
                motionOffset.gamma = e.gamma;
                initialMotionSet = true;
            }
            const sensitivity = 20;
            // Gamma è inclinazione destra/sinistra (-90 a 90)
            // Beta è inclinazione avanti/dietro (-180 a 180)
            motionInput.x = Math.max(-1, Math.min(1, (e.gamma - motionOffset.gamma) / sensitivity));
            motionInput.y = Math.max(-1, Math.min(1, -(e.beta - motionOffset.beta) / sensitivity));
        });
    }

    async function requestMotionPermission() {
        if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
            try {
                const response = await DeviceOrientationEvent.requestPermission();
                if (response === 'granted') {
                    useMotion = true;
                    initialMotionSet = false;
                }
            } catch (e) { console.error("Sensors error"); }
        } else {
            useMotion = window.DeviceOrientationEvent !== undefined;
        }
    }

    function animate() {
        requestAnimationFrame(animate);
        if (gameState === 'START' || gameState === 'MATCH_OVER') { renderer.render(scene, camera); return; }
        if (audioCtx.state === 'running') scheduler();
        updateSmoke();

        // Animazione anelli
        tunnelRings.forEach((ring, i) => {
            ring.material.emissiveIntensity = 0.5 + Math.sin(Date.now() * 0.002 + i) * 0.5;
            if (gameState === 'PLAYING') {
                ring.position.z += stats.currentSpeed * 0.05;
                if (ring.position.z > ARENA_DEPTH / 2) ring.position.z = -ARENA_DEPTH / 2;
            }
        });

        if (gameState === 'INTRO') {
            introProgress += 0.007;
            const radius = 100 * (1 - introProgress) + 15 * introProgress; 
            camera.position.x = Math.cos(introProgress * Math.PI) * radius;
            camera.position.y = 40 * (1 - introProgress) + 4 * introProgress;
            camera.position.z = Math.sin(introProgress * Math.PI) * radius + (ARENA_DEPTH/2 * introProgress);
            camera.lookAt(0, 0, ball.position.z * 0.5);
            if (introProgress >= 1) {
                gameState = 'WAITING';
                document.getElementById('click-prompt').classList.remove('hidden');
            }
        }

        starField.position.z += 0.3;
        if(starField.position.z > 500) starField.position.z = 0;

        // Somma input (touch + eventuale motion)
        currentInput.x = THREE.MathUtils.clamp(pointerInput.x + motionInput.x, -1, 1);
        currentInput.y = THREE.MathUtils.clamp(pointerInput.y + motionInput.y, -1, 1);

        const limit = RADIUS - PADDLE_RADIUS - 0.5;
        playerPaddle.position.x = THREE.MathUtils.lerp(playerPaddle.position.x, currentInput.x * limit, 0.2); 
        playerPaddle.position.y = THREE.MathUtils.lerp(playerPaddle.position.y, currentInput.y * limit, 0.2);
        playerPaddle.rotation.z += 0.02;

        if (gameState === 'WAITING') {
            ball.position.set(playerPaddle.position.x, playerPaddle.position.y, playerPaddle.position.z - 3);
            ballLight.intensity = 2 + Math.sin(Date.now() * 0.01) * 1.5;
        }

        if (gameState === 'PLAYING') {
            ball.position.add(ballVelocity);
            createTrailEffect(); // Aggiunge scia durante il movimento

            const currentSpeed = ballVelocity.length();
            if (currentSpeed < targetSpeed) ballVelocity.setLength(THREE.MathUtils.lerp(currentSpeed, targetSpeed, 0.05));

            const ballDist = Math.sqrt(ball.position.x**2 + ball.position.y**2);
            const maxBound = RADIUS - BALL_RADIUS - 0.1;
            if (ballDist > maxBound) {
                const normal = new THREE.Vector3(ball.position.x, ball.position.y, 0).normalize();
                ballVelocity.reflect(normal);
                ball.position.x = normal.x * maxBound;
                ball.position.y = normal.y * maxBound;
                createSmokeEffect(ball.position.clone(), playerColor, 5);
            }

            cpuPaddle.position.x += (ball.position.x - cpuPaddle.position.x) * (0.04 + stats.level * 0.012);
            cpuPaddle.position.y += (ball.position.y - cpuPaddle.position.y) * (0.04 + stats.level * 0.012);
            
            const collDist = PADDLE_RADIUS + BALL_RADIUS;
            if (ballVelocity.z > 0 && ball.position.z > playerPaddle.position.z - 1.2) {
                if (Math.sqrt((ball.position.x - playerPaddle.position.x)**2 + (ball.position.y - playerPaddle.position.y)**2) < collDist) {
                    ballVelocity.z *= -1;
                    targetSpeed = Math.min(targetSpeed + SPEED_INCREMENT, MAX_SPEED_CAP + stats.level * 0.2);
                    ballVelocity.setLength(targetSpeed);
                    feedbackPaddle(playerPaddle);
                }
            }
            if (ballVelocity.z < 0 && ball.position.z < cpuPaddle.position.z + 1.2) {
                if (Math.sqrt((ball.position.x - cpuPaddle.position.x)**2 + (ball.position.y - cpuPaddle.position.y)**2) < collDist) {
                    ballVelocity.z *= -1;
                    targetSpeed = Math.min(targetSpeed + SPEED_INCREMENT, MAX_SPEED_CAP + stats.level * 0.2);
                    ballVelocity.setLength(targetSpeed);
                    feedbackPaddle(cpuPaddle);
                }
            }

            if (ball.position.z > ARENA_DEPTH/2 + 10) handleGoal(false);
            if (ball.position.z < -ARENA_DEPTH/2 - 10) handleGoal(true);
            stats.currentSpeed = ballVelocity.length();
            updateUI();
        }

        if (gameState === 'PLAYING' || gameState === 'WAITING') {
            camera.position.lerp(new THREE.Vector3(playerPaddle.position.x*0.5, playerPaddle.position.y*0.5+4, ARENA_DEPTH/2+15), 0.1);
            camera.lookAt(ball.position.x*0.1, ball.position.y*0.1, ball.position.z*0.2);
        }
        renderer.render(scene, camera);
    }

    function feedbackPaddle(p) {
        p.children[0].material.emissiveIntensity = 15;
        setTimeout(() => p.children[0].material.emissiveIntensity = 2.5, 150);
    }

    async function initAndStart() {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        await requestMotionPermission();
        
        playerPaddle.children[0].material.color.setHex(playerColor);
        playerPaddle.children[0].material.emissive.setHex(playerColor);
        playerPaddle.children[1].material.color.setHex(playerColor);
        
        tunnelRings.forEach(ring => {
            ring.material.color.setHex(playerColor);
            ring.material.emissive.setHex(playerColor);
        });

        document.getElementById('start-screen').classList.add('hidden');
        gameState = 'INTRO';
        updateUI();
    }

    function resetToWait() {
        gameState = 'WAITING';
        ballVelocity.set(0,0,0);
        targetSpeed = 1.4 + (stats.level * 0.2);
        document.getElementById('click-prompt').classList.remove('hidden');
    }

    function launchBall() {
        document.getElementById('click-prompt').classList.add('hidden');
        gameState = 'PLAYING';
        ballVelocity.set((Math.random()-0.5)*0.5, (Math.random()-0.5)*0.5, -targetSpeed);
    }

    function handleGoal(isP) {
        if (isP) stats.playerScore++;
        else stats.cpuScore++;
        
        updateUI();

        if (stats.playerScore >= WINNING_SCORE || stats.cpuScore >= WINNING_SCORE) {
            endMatch();
        } else {
            resetToWait();
        }
    }

    function endMatch() {
        gameState = 'MATCH_OVER';
        const win = stats.playerScore >= WINNING_SCORE;
        const delta = Math.abs(stats.playerScore - stats.cpuScore);
        const pointsChange = delta * 100;
        
        const msg = document.getElementById('match-msg');
        msg.innerText = win ? `Vittoria! +${pointsChange}` : `Sconfitta! -${pointsChange}`;
        msg.style.color = win ? "#00ff00" : "#ff0000";
        msg.style.opacity = 1;

        if (win) {
            stats.totalPoints += pointsChange;
            if (stats.level < MAX_LEVELS) stats.level++;
            else {
                msg.innerText = "CAMPIONE DEL TUNNEL!";
            }
        } else {
            stats.totalPoints -= pointsChange;
        }

        setTimeout(() => {
            msg.style.opacity = 0;
            // Game Over se punti <= 0 E hai perso (impedisce game over immediato all'inizio)
            if (stats.totalPoints <= 0 && !win) {
                gameOver();
            } else {
                if (stats.totalPoints < 0) stats.totalPoints = 0;
                prepareNextMatch();
            }
        }, 2500);
    }

    function gameOver() {
        const msg = document.getElementById('match-msg');
        msg.innerText = "GAME OVER";
        msg.style.color = "#ff0000";
        msg.style.opacity = 1;
        
        stats.level = 1;
        stats.totalPoints = 0;
        
        setTimeout(() => {
            location.reload(); 
        }, 3000);
    }

    function prepareNextMatch() {
        document.getElementById('match-msg').style.opacity = 0;
        stats.playerScore = 0;
        stats.cpuScore = 0;
        updateUI();
        resetToWait();
    }

    function updateUI() {
        document.getElementById('player-score').innerText = stats.playerScore;
        document.getElementById('cpu-score').innerText = stats.cpuScore;
        document.getElementById('level-val').innerText = `LEVEL ${stats.level < 10 ? '0'+stats.level : stats.level}`;
        document.getElementById('score-total').innerText = String(Math.max(0, stats.totalPoints)).padStart(4, '0');
        document.getElementById('speed-indicator').innerText = stats.currentSpeed.toFixed(1);
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    window.onload = () => { initThree(); animate(); };
</script>
</body>
</html>
