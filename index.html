<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>3D Crystal Shatter - Universal Edition</title>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.tailwindcss.com"></script>

<style>
@import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

body {
    margin:0; overflow:hidden; background:#020205;
    font-family:'Orbitron',sans-serif;
    user-select:none; touch-action:none;
}
canvas { display:block }
</style>
</head>

<body>

<script>
/* =======================
   CONFIG
======================= */
let scene, camera, renderer;
let ball, playerPaddle, cpuPaddle;
let ballVelocity = new THREE.Vector3();

const RADIUS = 10;
const ARENA_DEPTH = 80;
const PADDLE_RADIUS = 3.675;
const BALL_SPEED_START = 0.55;
const MAX_SPEED = 1.8;

let gameState = 'START';
let stats = { level:1, lives:3, playerScore:0, cpuScore:0, totalPoints:0 };

let currentInputX = 0, currentInputY = 0;
let motionActive = false;
let lastMotionTime = 0;

/* =======================
   INIT
======================= */
function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x020205);
    scene.fog = new THREE.Fog(0x020205,40,110);

    camera = new THREE.PerspectiveCamera(75,innerWidth/innerHeight,0.1,1000);

    renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setSize(innerWidth,innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio,2));
    document.body.appendChild(renderer.domElement);

    scene.add(new THREE.AmbientLight(0xffffff,0.3));
    scene.add(new THREE.PointLight(0x00f2ff,1.5,100)).position.set(0,8,20);
    scene.add(new THREE.PointLight(0xff00ea,1.5,100)).position.set(0,-8,-20);

    const arena = new THREE.Mesh(
        new THREE.CylinderGeometry(RADIUS,RADIUS,ARENA_DEPTH,32,1,true),
        new THREE.MeshLambertMaterial({color:0x050508,side:THREE.BackSide})
    );
    arena.rotation.x = Math.PI/2;
    scene.add(arena);

    playerPaddle = createPaddle(0x00f2ff);
    playerPaddle.position.z = ARENA_DEPTH/2 - 4;
    scene.add(playerPaddle);

    cpuPaddle = createPaddle(0xff00ea,1.5);
    cpuPaddle.position.z = -ARENA_DEPTH/2 + 4;
    scene.add(cpuPaddle);

    ball = new THREE.Mesh(
        new THREE.SphereGeometry(1.2,16,16),
        new THREE.MeshStandardMaterial({color:0xffffff,emissive:0xffaa00,emissiveIntensity:5})
    );
    ball.add(new THREE.PointLight(0xffaa00,6,20));
    scene.add(ball);

    setupEvents();
    resetBall();
    animate();
}

/* =======================
   OBJECTS
======================= */
function createPaddle(color, brightness=1) {
    const g = new THREE.Group();
    const disc = new THREE.Mesh(
        new THREE.CylinderGeometry(PADDLE_RADIUS,PADDLE_RADIUS,0.3,32),
        new THREE.MeshStandardMaterial({color,transparent:true,opacity:0.4})
    );
    disc.rotation.x = Math.PI/2;
    g.add(disc);

    const ring = new THREE.Mesh(
        new THREE.TorusGeometry(PADDLE_RADIUS,0.2,8,48),
        new THREE.MeshStandardMaterial({color,emissive:color,emissiveIntensity:10*brightness})
    );
    g.add(ring);
    g.userData.ring = ring;
    return g;
}

/* =======================
   EVENTS
======================= */
function setupEvents() {
    addEventListener('resize',()=>{
        camera.aspect = innerWidth/innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(innerWidth,innerHeight);
    });

    addEventListener('mousemove',e=>{
        if(performance.now() - lastMotionTime > 500){
            motionActive = false;
        }
        if(!motionActive){
            currentInputX = e.clientX/innerWidth*2-1;
            currentInputY = -(e.clientY/innerHeight*2-1);
        }
    });

    addEventListener('keydown',e=>{
        if(e.key === 'Escape'){
            gameState = gameState === 'PAUSE' ? 'PLAYING' : 'PAUSE';
        }
    });

    setupMotion();
}

/* iOS accelerometer permission */
function setupMotion(){
    if(typeof DeviceOrientationEvent !== 'undefined' &&
       typeof DeviceOrientationEvent.requestPermission === 'function'){
        DeviceOrientationEvent.requestPermission().then(r=>{
            if(r==='granted') enableMotion();
        }).catch(()=>{});
    } else {
        enableMotion();
    }
}

function enableMotion(){
    addEventListener('deviceorientation',e=>{
        if(Math.abs(e.gamma)>2 || Math.abs(e.beta-45)>2){
            motionActive = true;
            lastMotionTime = performance.now();
            currentInputX = THREE.MathUtils.clamp(e.gamma/25,-1,1);
            currentInputY = THREE.MathUtils.clamp(-(e.beta-45)/25,-1,1);
        }
    });
}

/* =======================
   GAME LOOP
======================= */
function animate(){
    requestAnimationFrame(animate);
    if(gameState === 'PAUSE'){
        renderer.render(scene,camera);
        return;
    }

    const limit = RADIUS - PADDLE_RADIUS - 0.5;
    playerPaddle.position.x += (currentInputX*limit - playerPaddle.position.x)*0.2;
    playerPaddle.position.y += (currentInputY*limit - playerPaddle.position.y)*0.2;

    if(gameState === 'WAITING'){
        ball.position.set(
            playerPaddle.position.x,
            playerPaddle.position.y,
            playerPaddle.position.z - 2
        );
    }

    if(gameState === 'PLAYING'){
        ball.position.add(ballVelocity);

        ballVelocity.clampLength(0,MAX_SPEED);

        const dist = Math.hypot(ball.position.x,ball.position.y);
        if(dist > RADIUS-1.2){
            const n = new THREE.Vector3(ball.position.x,ball.position.y,0).normalize();
            ballVelocity.reflect(n);
        }

        const ease = 0.08 + stats.level*0.03;
        const error = (Math.random()-0.5)*0.5;
        cpuPaddle.position.x += ((ball.position.x+error)-cpuPaddle.position.x)*ease;
        cpuPaddle.position.y += ((ball.position.y+error)-cpuPaddle.position.y)*ease;

        checkPaddleHit(playerPaddle,1);
        checkPaddleHit(cpuPaddle,-1);

        if(ball.position.z > ARENA_DEPTH/2+2) goal(false);
        if(ball.position.z < -ARENA_DEPTH/2-2) goal(true);
    }

    camera.position.lerp(
        new THREE.Vector3(
            playerPaddle.position.x*0.3,
            playerPaddle.position.y*0.3+4,
            playerPaddle.position.z+20
        ),0.05
    );
    camera.lookAt(0,0,ball.position.z*0.5);

    renderer.render(scene,camera);
}

/* =======================
   COLLISION & GOAL
======================= */
function checkPaddleHit(p,dir){
    if(ballVelocity.z*dir>0) return;
    if(Math.abs(ball.position.z-p.position.z)>1.5) return;

    const d = Math.hypot(
        ball.position.x-p.position.x,
        ball.position.y-p.position.y
    );

    if(d < PADDLE_RADIUS+1.2){
        ballVelocity.z *= -1.05;
        ballVelocity.x += (ball.position.x-p.position.x)*0.2;
        ballVelocity.y += (ball.position.y-p.position.y)*0.2;
    }
}

function goal(player){
    gameState = 'WAITING';
    stats[player?'playerScore':'cpuScore']++;
    flash();
    resetBall();
}

function flash(){
    renderer.toneMappingExposure = 2;
    setTimeout(()=>renderer.toneMappingExposure=1,120);
}

/* =======================
   BALL
======================= */
function resetBall(){
    ballVelocity.set(0,0,0);
    gameState = 'WAITING';
    setTimeout(launchBall,500);
}

function launchBall(){
    const s = BALL_SPEED_START + stats.level*0.05;
    ballVelocity.set(
        (Math.random()-0.5)*0.2,
        (Math.random()-0.5)*0.2,
        -s
    );
    gameState = 'PLAYING';
}

onload = init;
</script>

</body>
</html>
